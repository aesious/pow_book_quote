
# Proof of work: book of quotes

## What you need installed
Only `make` and `docker-compose`.

## What you can do
### Easy run
One-liner to start server and run client against it:  
`make build && make start-server && make run-client`

### Build
`make build` - (re)builds client and server.  
`make build-server` - (re)builds only server.  
`make build-client` - (re)builds only client.

### Test (build required)
`make test-server`   
No tests for client yet.

### Run (build required)
`make start-server` - starts server in background.  
`make run-client` - performs n requests to server in parallel and stops.

### Help (build required)
`make help-server` - shows how you can start server with params.  
`make help-client` - shows how you can run client with params.

### Clean
`make clean` - completely cleans your docker environment from the app.

## Design
Server has 2 endpoints:
* `getChallenge` - returns a new challenge to a client upon request
* `getBookQuote` - validates client's challenge+solution and sends a book quote to the client  

Client gets a new challenge, calculates solution to it and then provides challenge+solution to the server to obtain a book quote.
### How challenge is solved
Challenge is 32 bytes generated with CSPRNG.
Solution is another 4 bytes so that first 4 bytes of sha256(challenge+solution) are less than some uint32 target. Target is a parameter. Such an approach is chosen over trivial hashcash where complexity of calculation is not as flexible.
### How challenge is generated on the server
A trivial approach would be to generate challenge totally random. In this case, an attacker could just provide any precalculated challenge with its solution and a server would have to accept it. To mitigate it, a server could remember all recently generated challenges and accept only their solutions. Storing them in a set is not an option since it'd be easy to DDOS such a server simply by spawning many `getChallenge` requests and making the set grow infinitely. A better approach is the following:
* at every moment on a server, there are a few 16-byte challenge prefixes
* every few seconds a new prefix is generated and the oldest one is expired
* prefixes are generated by a server with CSPRNG and can not be guessed by an attacker
* to generate a new challenge, a server simply takes the newest prefix and appends randomly generated nonce to it

This makes it impossible to guess what challenges a server will generate at some point in the future, makes it easy to check if challenge is recent without any memory pressure on a server.
### How solution is validated (is there any room for attack?)
A client can provide solution only to some subset of recently generated challenges and that's good. However, one attack remains possible: the same solution (to a valid recent challenge) can be provided by multiple clients multiple times. To prevent re-use of solutions, a server has to remember recently solved challenges. Keeping solved challenges **would not create much thread contention** since:
* an attacker still needs to calculate a solution before they can try DDOS
* if botnet comes the majority of requests in such an attack would fail when *reading* from recently solved challenges and sync.Map is of great use (sync.Map is specialized for heavy reads)
* and there would not be contention with writes of other clients because reads and writes would mostly be to disjoint keys for which sync.Map is also greatly specialized

There's a sync.Map per challenge prefix, so that when prefix expires a sync.Map  also easily expires.
### Overall, is there thread contention?
There's no thread contention between client requests.
However, there's contention between client requests and a background goroutine which updates challenge prefixes every few seconds but it should be negligible.

### Code
There's `challenge` package in server code and it's the most complicated.
The interface of the package is:
```go
// Sets difficulty of challenges.
challenge.SetHashPuzzleDifficulty(5000)
...
ch, err := challenge.NewChallenge(ctx)
...
// err is one of: ErrChallengeNotRecent, ErrAlreadySolved, ErrSolutionIsInvalid
err := challenge.PassSolution(ctx, ch, solutionBytes)
```